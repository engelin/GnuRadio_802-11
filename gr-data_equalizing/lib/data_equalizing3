/* -*- c++ -*- */
/* 
 * Copyright 2016 <+YOU OR YOUR COMPANY+>.
 * 
 * This is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 * 
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <gnuradio/io_signature.h>
#include "data_equalizing_impl.h"

#include <cfloat>
#include <Eigen/Dense>
#include <itpp/itcomm.h>

using namespace Eigen;
using namespace itpp;

namespace gr {
  namespace data_equalizing {

    data_equalizing::sptr
    data_equalizing::make()
    {
      return gnuradio::get_initial_sptr
        (new data_equalizing_impl());
    }

    /*
     * The private constructor
     */
    data_equalizing_impl::data_equalizing_impl()
      : gr::block("data_equalizing",
              gr::io_signature::make2(2, 2, 64 * sizeof(gr_complex), 64 * sizeof(gr_complex)),
              gr::io_signature::make(1, 1, 64 * sizeof(gr_complex)))
    {
      this->d_nsym = 0;
      this->count = 0;
    }

    /*
     * Our virtual destructor.
     */
    data_equalizing_impl::~data_equalizing_impl()
    {
    }

    void
    data_equalizing_impl::data_equalizer(gr_complex *fft_data, gr_complex *re_encoding_data, gr_complex *out) {
      double fft_r[64];
      double fft_i[64];
      double re_r[64];
      double re_i[64];
      double temp_r[64];
      double temp_i[64];
      double out_r[64];
      double out_i[64];
      gr_complex temp[64];

      for(int n = 0; n < 64; n++) {
        fft_r[n] = std::real(fft_data[n]);
        fft_i[n] = std::imag(fft_data[n]);
        re_r[n] = std::real(re_encoding_data[n]);
        re_i[n] = std::imag(re_encoding_data[n]);
      }

      std::cout << "channel data eq.." << std::endl;
      for(int n = 0; n < 64; n++) {

	//if(re_r[n] == 0) re_r[n] = 0.001;
	//if(re_i[n] == 0) re_i[n] = 0.001;

	//out_r[n] = ((fft_r[n] * re_r[n] + fft_i[n] * re_i[n]) / (re_r[n] * re_r[n] + re_i[n] * re_i[n])) * this->first_symbol_r[n] - ((fft_i[n] * re_r[n]- fft_r[n] * re_i[n]) / (re_r[n] * re_r[n] + re_i[n] * re_i[n])) * this->first_symbol_i[n];

	//out_i[n] = ((fft_r[n] * re_r[n] + fft_i[n] * re_i[n]) / (re_r[n] * re_r[n] + re_i[n] * re_i[n])) * this->first_symbol_i[n] + ((fft_i[n] * re_r[n]- fft_r[n] * re_i[n]) / (re_r[n] * re_r[n] + re_i[n] * re_i[n])) * this->first_symbol_r[n];

	temp_r[n] = (fft_r[n] * re_r[n] + fft_i[n] * re_i[n]) / (re_r[n] * re_r[n] + re_i[n] * re_i[n]);
	temp_i[n] = (fft_i[n] * re_r[n] - fft_r[n] * re_i[n]) / (re_r[n] * re_r[n] + re_i[n] * re_i[n]);

	if((re_r[n] == 0) && (re_i[n] == 0)) {
	  temp_r[n] = fft_r[n];
	  temp_i[n] = fft_i[n];
	}

	temp[n] = gr_complex(temp_r[n], temp_i[n]);
	std::cout << temp[n] << " ";

	out_r[n] = temp_r[n] * this->first_symbol_r[n] - temp_i[n] * this->first_symbol_i[n];
	out_i[n] = temp_r[n] * this->first_symbol_i[n] + temp_i[n] * this->first_symbol_i[n];

	out[n] = gr_complex(out_r[n], out_i[n]);
      } std::cout << std::endl;
    }


    void
    data_equalizing_impl::real_channel(gr_complex *in, gr_complex *out, int n) {
      //int gain[35] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35};
      double in_r[64];
      double in_i[64];
      double out_r[64];
      double out_i[64];

      std::cout << "channel out" << std::endl;
      for (int i = 0; i < 64; i++) {
	in_r[i] = std::real(in[i]);
	in_i[i] = std::imag(in[i]);

	out_r[i] = (n + 1) * (in_r[i] - in_i[i]);
	out_i[i] = (n + 1) * (in_r[i] + in_i[i]);

	out[i] = gr_complex(out_r[i], out_i[i]);
	//out[i] = in[i] * (n+1);
	std::cout << out[i] << " ";
      } std::cout << std::endl;
    }

    

    void
    data_equalizing_impl::forecast (int noutput_items, gr_vector_int &ninput_items_required)
    {
        /* <+forecast+> e.g. ninput_items_required[0] = noutput_items */
    }

    int
    data_equalizing_impl::general_work (int noutput_items,
                       gr_vector_int &ninput_items,
                       gr_vector_const_void_star &input_items,
                       gr_vector_void_star &output_items)
    {
        const gr_complex *in_re_data = (const gr_complex *) input_items[0];
	const gr_complex *in_fft_data = (const gr_complex *) input_items[1];
        gr_complex *out = (gr_complex *) output_items[0];

	int symbols_to_read = 0;
	int ninput = std::min(ninput_items[0], ninput_items[1]);
	symbols_to_read = std::min(noutput_items, ninput);
	noutput_items = symbols_to_read;

	int i = 0;
	int o = 0;

	std::vector<gr::tag_t> tags;
	const uint64_t nread = nitems_read(0);

	//while((i < ninput) && (o < noutput_items)) {
	while(i < ninput) {
	  //std::cout << "input re_encoding data num: "  << ninput_items[0] << " fft data num : " << ninput_items[1] << std::endl;
	  get_tags_in_window(tags, 0, nread + i, nread + symbols_to_read);

	  if(tags.size()) {
	    this->d_nsym = 0;
	  }

	  //if(this->d_nsym  == 0) {
	  if(this->count == 0) {
	    //std::memcpy(this->first_symbol, in_re_data, 64 * sizeof(gr_complex));
	    for(int n = 0; n < 64; n++) {
	      this->first_symbol[n] = std::complex<float>(in_re_data[n]);
	      this->first_symbol_r[n] = std::real(in_re_data[n]);
	      this->first_symbol_i[n] = std::imag(in_re_data[n]);
//std::cout << n << " : re : " << in_re_data[n] << ", fft : " << in_fft_data[n] << "  ";
	    } //std::cout << std::endl; std::cout << std::endl;
	    //std::cout << "first_symbol copy.." << std::endl;
	  }

	  std::cout << o << "th data" << std::endl;
	  for(int n = 0; n < 64; n++) {
	    std::cout << in_fft_data[n] << " ";
	  } std::cout << std::endl;
	  gr_complex temp[64];
	  real_channel((gr_complex *)in_fft_data, temp, o);
	  data_equalizer(temp, (gr_complex * )in_re_data, out);
	  /*for(int n = 0; n < 64; n++) {
	    temp[n] = gr_complex(0, 0);
	    }*/
	  //data_equalizer(temp, (gr_complex *)in_re_data, out);
	  //data_equalizer((gr_complex *)in_fft_data, (gr_complex *)in_re_data, out);

	  std::cout << o << "th d_e out : " << std::endl;
          for(int n = 0; n < 64; n++) {
            std::cout << out[n] << " ";
	  }std::cout << std::endl;


/*	  std::cout << o << "th out : " << std::endl;
	  for(int n = 0; n < 64; n++) {
	    std::cout << this->temp[n] << " ";
	  }std::cout << "\n" << std::endl;*/

	  this->count++;
	  if(this->count == ninput_items[0]) {
	    this->count = 0;
	  }

	  out += 64;
	  o++;
	  in_fft_data += 64;
	  in_re_data += 64;
	  i++;
	  this->d_nsym++;
	}

        // Do <+signal processing+>
        // Tell runtime system how many input items we consumed on
        // each input stream.
        //consume_each (noutput_items);
	consume(0, i);
	consume(1, i);

        // Tell runtime system how many output items we produced.
        //return noutput_items;
	return o;
    }

  } /* namespace data_equalizing */
} /* namespace gr */

